/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   test.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: dlesieur <dlesieur@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/10/21 14:00:22 by dlesieur          #+#    #+#             */
/*   Updated: 2025/10/21 17:18:06 by dlesieur         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../ft_ctype.h"
#include "global.h"
#include <string.h>
#include <stdio.h>
#include <ctype.h>

typedef int (*t_ofn)(int);
typedef const char *(*t_msg)(t_state);
typedef unsigned char t_little_int; // max 255 range

// ANSI color codes
#define COLOR_RESET "\033[0m"
#define COLOR_GREEN "\033[1;32m"
#define COLOR_CYAN "\033[1;36m"
#define COLOR_YELLOW "\033[1;33m"
#define COLOR_RED "\033[1;31m"

// Message table for severity (with emoji/symbols)
static const char	*msg_table[] = {
	"✅ OK",
	"ℹ️  INFO",
	"⚠️  WARNING",
	"❌ ERROR"};

// Color table for severity
static const char	*color_table[] = {
	COLOR_GREEN,
	COLOR_CYAN,
	COLOR_YELLOW,
	COLOR_RED};

// Remove these global static tables:
// static t_ofn ft_table[] = { ... };
// static t_ofn std_table[] = { ... };

static t_ofn	*g_std_table = NULL;

t_state	ft_assert(void *comp1, void *comp2, size_t n)
{
	int	res;

	if (!comp1 && !comp2)
		return (ST_OK_MATCH);
	if (!comp1 || !comp2)
		return (ST_ERR_FATAL);
	res = memcmp(comp1, comp2, n);
	if (res == 0)
		return (ST_OK_MATCH);
	if (res < 0)
		return (ST_LT);
	return (ST_GT);
}

t_state	detect_severity(t_state st)
{
	if ((int)st >= (int)SEV_OK && (int)st < (int)SEV_INFO)
		return (0); // OK
	else if ((int)st >= (int)SEV_INFO && (int)st < (int)SEV_WARNING)
		return (1); // INFO
	else if ((int)st >= (int)SEV_WARNING && (int)st < (int)SEV_ERR)
		return (2); // WARNING
	else
		return (3); // ERROR
}

void	prompt_result(t_state st)
{
	t_state	sev;

	sev = detect_severity(st);
	printf("%s%s%s\n", color_table[sev], msg_table[sev], COLOR_RESET);
}

t_state	ctype_test(int (*ft)(int), int ref_index, int *test_total, int *test_passed)
{
	int			i;
	size_t		fn_count;
	t_state		st;
	int			exit_code_mismatches;
	t_monitore	mon;
	int			result1;
	int			result2;
	int			truth1;
	int			truth2;

	fn_count = 10;
	exit_code_mismatches = 0;
	mon.out_given = NULL;
	mon.out_expected = NULL;
	mon.case_total = 0;
	mon.case_passed = 0;
	mon.test_total = test_total;
	mon.test_passed = test_passed;
	mon.st = ST_OK;
	mon.exit_code = 0;

	if (ref_index < 0 || (size_t)ref_index >= fn_count)
		return (ST_ERR_FATAL);
	i = -1;
	while (++i < AMAX)
	{
		result1 = ft(i);
		result2 = g_std_table[ref_index](i);
		truth1 = !!result1;
		truth2 = !!result2;
		monitore_set_out1(&mon, &result1, sizeof(int));
		monitore_set_out2(&mon, &result2, sizeof(int));
		st = (truth1 == truth2) ? ST_OK_MATCH : ST_ERR_MATCH;
		mon.st = st;
		mon.exit_code = (truth1 == truth2) ? 0 : 1;
		if (mon.exit_code != 0)
		{
			exit_code_mismatches++;
			printf("[DEBUG] input=%d, ft=%d, std=%d, !!ft=%d, !!std=%d\n",
				   i, result1, result2, truth1, truth2);
		}
		mon.case_total++;
		if (st == ST_OK_MATCH)
			mon.case_passed++;
		(*test_total)++;
		if (st == ST_OK_MATCH)
			(*test_passed)++;
	}
	monitore_free(&mon);
	if (exit_code_mismatches > 0)
		printf("\033[1;33mExit code mismatches: %d/%d\033[0m\n", exit_code_mismatches, mon.case_total);
	printf("\033[1;36mScore: %d/%d cases passed\033[0m\n", mon.case_passed, mon.case_total);
	return (mon.case_passed == mon.case_total ? ST_OK : ST_ERR_MATCH);
}

int main(void)
{
	t_ofn ft_table[] = {
		ft_isalnum,
		ft_isblank,
		ft_isdigit,
		ft_isgraph,
		ft_islower,
		ft_isprint,
		ft_isspace,
		ft_isupper,
		ft_tolower,
		ft_toupper};
	t_ofn std_table[] = {
		isalnum,
		isblank,
		isdigit,
		isgraph,
		islower,
		isprint,
		isspace,
		isupper,
		tolower,
		toupper};
	size_t fn_count = sizeof(ft_table) / sizeof(ft_table[0]), i;
	const char *fn_names[] = {
		"isalnum", "isblank", "isdigit", "isgraph", "islower",
		"isprint", "isspace", "isupper", "tolower", "toupper"};
	t_state st;
	int test_total = 0;
	int test_passed = 0;
	g_std_table = std_table;
	for (i = 0; i < fn_count; ++i)
	{
		printf("\n\033[1;34m=== Testing %s ===\033[0m\n", fn_names[i]);
		st = ctype_test(ft_table[i], i, &test_total, &test_passed);
		if (st == ST_OK)
			printf("\033[1;32mAll tests passed for %s!\033[0m\n", fn_names[i]);
		else
			printf("\033[1;31mSome tests failed for %s.\033[0m\n", fn_names[i]);
	}
	printf("\n\033[1;35mGlobal summary: %d/%d cases passed (%.2f%%)\033[0m\n",
		   test_passed, test_total, test_total ? (100.0 * test_passed / test_total) : 0.0);
	return (0);
}