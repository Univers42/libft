I need you to reimplement the error.h and error.c from src/
into my own error.c error.h from libft/

but there are some rules to respects, we need the exact same logic, global variables are prohibited so we need to do a structure to pass by argument if they're speific to the error system if they're signals then we would use our struct there

typedef struct s_glob_sig
{
    int sigmodes[BASH_NSIG_TOTAL];
    volatile int from_return_trap;
    volatile int sigwinch_received;
    volatile sig_atomic_t intpending;
    volatile int sigterm_received;
    int interrupt_immediately;
    int terminate_immediately;
    int builtin_catch_sigpipe;
    int waiting_for_child;
    void *original_signals[NSIG];
    char *trap_list[BASH_NSIG_TOTAL];
    int pending_traps[NSIG];
    int running_traps;
    int trap_return_context;
    int trap_saved_exit_value;
    int wait_signal_received;
    int trapped_signal_received;
    int suppress_debug_trap_verbose;
    int catch_flag;
    int function_trace_mode;
    int error_trace_mode;
    int reset_signal;
    char *signal_name[NSIG];
    int interactive;
} t_glob_sig;

into trap.h

jump syntax goto, switch are totally prohibited so we have to find a by pass while respeciting the same logic and the macro instructions are totally prohibitted they should be found into the global scope never into the inner scope

for instance

void
exraise(int e)
{
#ifdef DEBUG
    if (handler == NULL)
        abort();
#endif

    if (vforked)
        _exit(exitstatus);

    INTOFF;

    exception = e;
    longjmp(handler->loc, 1);
}


this kind of instruction debug should be called into the outer scope not the inner so we should wrape into a util function things lke htat and call the util instead
